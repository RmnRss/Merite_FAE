# Modules
import pandas as pd
import math
import matplotlib.pyplot as plt

# Fenetre de courbes
plt.figure(1)

# Ouverture du fichier
data_file = pd.read_csv("LANCER_2.CSV")

# Stockage des différentes colonnes de données dans des listes grace au module Panda
raw_time = data_file.Temps.tolist()
raw_accX = data_file.AccelX.tolist()
raw_accY = data_file.AccelY.tolist()
raw_accZ = data_file.AccelZ.tolist()
raw_gyrX = data_file.GyroX.tolist()
raw_gyrY = data_file.GyroY.tolist()
raw_gyrZ = data_file.GyroZ.tolist()
raw_altitude = data_file.Altitude.tolist()
raw_pressure = data_file.Pression.tolist()
parachute_state = data_file.Parachute.tolist()

plt.plot(raw_time, raw_altitude)

# Passage des données de l'accéléromètre de g en ms^-2
raw_accX = [(x * 9.81) for x in raw_accX]
raw_accY = [(x * 9.81) for x in raw_accY]
raw_accZ = [(x * 9.81) for x in raw_accZ]

# Variables
dt = abs(raw_time[1] - raw_time[0])

# Determination de l'indice (numero d'échantillon) et du temps de lancement
launch_index = 0

while abs(raw_accX[launch_index+1] - raw_accX[launch_index]) < 9.8:
    launch_index += 1

launch_time = raw_time[launch_index]

print(launch_index)

# Suppréssion du bruit des capteurs
# On calcul la moyenne sur la periode pendant laquelle la fusée est stable
# Puis on soustrait cette moyenne aux valeurs relevé pendant le vol

sumaccX = sumaccY = sumaccZ = sumgyrX = sumgyrY = sumgyrZ = 0

for j in range(0, launch_index):
    sumaccX += raw_accX[j]
    sumaccY += raw_accY[j]
    sumaccZ += raw_accZ[j]
    sumgyrX += raw_gyrX[j]
    sumgyrY += raw_gyrY[j]
    sumgyrZ += raw_gyrZ[j]

offaccX = sumaccX/(launch_index-1)
offaccY = sumaccY/(launch_index-1)
offaccZ = sumaccZ/(launch_index-1)
offgyrX = sumgyrX/(launch_index-1)
offgyrY = sumgyrY/(launch_index-1)
offgyrZ = sumgyrZ/(launch_index-1)

print(offaccX)

# Suppréssion des données d'avant vol
del raw_time[:launch_index-1]
del raw_accX[:launch_index-1]
del raw_accY[:launch_index-1]
del raw_accZ[:launch_index-1]
del raw_gyrX[:launch_index-1]
del raw_gyrY[:launch_index-1]
del raw_gyrZ[:launch_index-1]
del raw_altitude[:launch_index-1]
del raw_pressure[:launch_index-1]
del parachute_state[:launch_index-1]

size = len(raw_time)

# Suppréssion des offsets
accX = [x - offaccX for x in raw_accX]
accY = [x - offaccY for x in raw_accY]
accZ = [x - offaccZ for x in raw_accZ]
gyrX = [x - offgyrX for x in raw_gyrX]
gyrY = [x - offgyrY for x in raw_gyrY]
gyrZ = [x - offgyrZ for x in raw_gyrZ]

# Lissage
# Si les varations sont trop faibles entre deux relevés alors on lisse la courbes entre ces points

for i in range(0, size-1):
    if abs(accX[i]-accX[i+1]) < 25:
        accX[i+1] = accX[i]

    if abs(accY[i]-accY[i+1]) < 5:
        accY[i+1] = accY[i]

    if abs(accZ[i]-accZ[i+1]) < 5:
        accZ[i+1] = accZ[i]

    if abs(gyrX[i]-gyrX[i+1]) < 1:
        gyrX[i+1] = gyrX[i]

    if abs(gyrY[i] - gyrY[i+1]) < 1:
        gyrY[i + 1] = gyrY[i]

    if abs(gyrZ[i] - gyrZ[i+1]) < 1:
        gyrZ[i + 1] = gyrZ[i]

# Intégration de la vitesse angulaire en position angulaire en degré

angleX = angleY = angleZ = [0] * size

for j in range(1, size):
    angleX[j] = angleX[j - 1] + (raw_time[j] - raw_time[j - 1]) * (gyrX[j] + gyrX[j - 1]) / 2

for k in range(1, size):
    angleY[k] = angleY[k - 1] + (raw_time[k] - raw_time[k - 1]) * (gyrY[k] + gyrY[k - 1]) / 2

for l in range(1, size):
    angleZ[l] = angleZ[l - 1] + (raw_time[l] - raw_time[l - 1]) * (gyrZ[l] + gyrZ[l - 1]) / 2

# PROJECTION SUR L'AXE PRINCIPAL
A = B = C = D = E = F = [0] * size
acc = [0] * size
    
for m in range(0, size):
    A[m] = math.cos(math.radians(angleY[m]))
    B[m] = - math.sin(math.radians(angleY[m]))
    C[m] = math.cos(math.radians(angleX[m]))
    D[m] = - math.sin(math.radians(angleX[m]))
    E[m] = math.cos(math.radians(angleZ[m]))
    F[m] = math.sin(math.radians(angleZ[m]))
    acc[m] = (B[m] * D[m] * E[m] + A[m] * F[m])*(-accY[m]) + (-B[m] * D[m] * F[m] + A[m] * E[m])*(-accX[m]) + (-B[m] * C[m])*(accZ[m]) + 9.81

# LISSAGE DE ACCELERATION
for i in range(0, size-1):
    if abs(acc[i] - acc[i+1]) < 5:
        acc[i + 1] = acc[i]

# INTEGRATION DE L'ACCELERATION EN H
    
vel = pos = [0] * size

for t in range(1, size-1):
    vel[t] = vel[t-1] + dt * (acc[t] + acc[t-1]) / 2

for t in range(1, size-1):
    pos[t] = pos[t-1] + dt * (vel[t] + vel[t-1]) / 2

plt.show()